{"version":3,"file":"static/js/317.36a39126.chunk.js","mappings":"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","sources":["../javascript/esm|F:/Code/fluidmotion/node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js","../javascript/esm|F:/Code/fluidmotion/node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js","../javascript/esm|F:/Code/fluidmotion/node_modules/@babel/runtime/helpers/esm/slicedToArray.js","../javascript/esm|F:/Code/fluidmotion/node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js","../javascript/esm|F:/Code/fluidmotion/node_modules/@babel/runtime/helpers/esm/iterableToArrayLimit.js","../javascript/esm|F:/Code/fluidmotion/node_modules/@babel/runtime/helpers/esm/nonIterableRest.js","waveWorker.js","../javascript/esm|F:/Code/fluidmotion/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js"],"sourcesContent":["export default function _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}","import arrayLikeToArray from \"./arrayLikeToArray.js\";\nexport default function _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);\n}","import arrayWithHoles from \"./arrayWithHoles.js\";\nimport iterableToArrayLimit from \"./iterableToArrayLimit.js\";\nimport unsupportedIterableToArray from \"./unsupportedIterableToArray.js\";\nimport nonIterableRest from \"./nonIterableRest.js\";\nexport default function _slicedToArray(arr, i) {\n  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || unsupportedIterableToArray(arr, i) || nonIterableRest();\n}","export default function _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}","export default function _iterableToArrayLimit(arr, i) {\n  var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"];\n\n  if (_i == null) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n\n  var _s, _e;\n\n  try {\n    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}","export default function _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}","const state = {\r\n  subdivisionRows: 0,\r\n\r\n  subdivisionColumns: 0,\r\n\r\n  columnsPerSubdivision: 0,\r\n\r\n  rowsPerSubdivision: 0,\r\n\r\n  minVertexDepth: 0,\r\n\r\n  maxVertexDepth: 0,\r\n\r\n  baseVertexDepth: 0,\r\n\r\n  vertexDepthRange: 0,\r\n\r\n  waveDampingFactor: 0.99,\r\n\r\n  sourcePositions: [],\r\n\r\n  resultPositions: [],\r\n\r\n  resetRequested: false,\r\n\r\n  pendingPointerEvents: new Map()\r\n};\r\n\r\nconst fns = {};\r\n\r\nfns.getZ = function(positions, vertexIndex) {\r\n  return positions[(vertexIndex * 3) + 2];\r\n};\r\n\r\nfns.setZ = function(positions, vertexIndex, value) {\r\n  positions[(vertexIndex * 3) + 2] = value;\r\n}\r\n\r\nfns.getScaledColor = function(positions, vertexIndex) {\r\n  return (fns.getZ(positions, vertexIndex) - state.minVertexDepth) / state.vertexDepthRange;\r\n};\r\n\r\nfns.handleInit = function(data) {\r\n  state.subdivisionRows = data.subdivisionRows;\r\n  state.subdivisionColumns = data.subdivisionColumns;\r\n  state.columnsPerSubdivision = data.columnsPerSubdivision;\r\n  state.rowsPerSubdivision = data.rowsPerSubdivision;\r\n  state.minVertexDepth = data.minVertexDepth;\r\n  state.maxVertexDepth = data.maxVertexDepth;\r\n  state.baseVertexDepth = data.minVertexDepth + ((data.maxVertexDepth - data.minVertexDepth) / 2);\r\n  state.vertexDepthRange = data.maxVertexDepth - data.minVertexDepth;\r\n  state.waveDampingFactor = data.waveDampingFactor;\r\n  state.resetRequested = false;\r\n\r\n  // Now create source, result positions, and vertex positions for each subdivision\r\n  for (let subRowIdx = 0; subRowIdx < state.subdivisionRows; subRowIdx++) {\r\n    \r\n    // Ensure that we have arrays for this row index\r\n    state.sourcePositions[subRowIdx] = [];\r\n    state.resultPositions[subRowIdx] = [];\r\n\r\n    // Now go through all of the columns in this row and copy the template\r\n    for (let subColIdx = 0; subColIdx < state.subdivisionColumns; subColIdx++) {\r\n      state.sourcePositions[subRowIdx][subColIdx] = new Float32Array(data.vertexPositionTemplate);\r\n      state.resultPositions[subRowIdx][subColIdx] = new Float32Array(data.vertexPositionTemplate);\r\n    }\r\n  }\r\n\r\n  // Reset the collection of pending pointer events.\r\n  state.pendingPointerEvents.clear();\r\n};\r\n\r\n/**\r\n * Handles when a reset has been requested.\r\n */\r\nfns.handleReset = function() {\r\n  state.resetRequested = true;\r\n  state.pendingPointerEvents.clear();\r\n};\r\n\r\n/**\r\n * Handles when the a pointer event has been logged.\r\n */\r\nfns.handlePointer = function(data) {\r\n  // Discard when we're resetting\r\n  if (state.resetRequested) {\r\n    return;\r\n  }\r\n\r\n  const key = `${data.rowIndex}_${data.columnIndex}_${data.vertexIndex}`;\r\n\r\n  state.pendingPointerEvents.set(\r\n    key,\r\n    {\r\n      rowIndex: data.rowIndex,\r\n      columnIndex: data.columnIndex,\r\n      vertexIndex: data.vertexIndex\r\n    });\r\n};\r\n\r\n/**\r\n * Handles when the consumer is ready for another wave by performing appropriate propagation operations.\r\n */\r\nfns.handleReady = function() {\r\n  const vertexCount = state.rowsPerSubdivision * state.columnsPerSubdivision;\r\n    \r\n  // Alias getZ because of how frequently we use it\r\n  const getZ = fns.getZ;\r\n\r\n  // First process all pointer events\r\n  if (state.resetRequested === false) {\r\n    for (let [/* key */, pointerEvent] of state.pendingPointerEvents) {\r\n      const sourcePositions = state.sourcePositions[pointerEvent.rowIndex][pointerEvent.columnIndex];\r\n      const resultPositions = state.resultPositions[pointerEvent.rowIndex][pointerEvent.columnIndex];\r\n\r\n      // Set the z-position to the minimum depth at this point\r\n      fns.setZ(sourcePositions, pointerEvent.vertexIndex, state.minVertexDepth);\r\n\r\n      // Maximize the result buffer at this point as well to maximize the amount of \"snap\"\r\n      fns.setZ(resultPositions, pointerEvent.vertexIndex, state.maxVertexDepth);\r\n    }\r\n  }\r\n  state.pendingPointerEvents.clear();\r\n\r\n  // Then perform propagation\r\n  for(let subRowIdx = 0; subRowIdx < state.subdivisionRows; subRowIdx++) {\r\n    for(let subColIdx = 0; subColIdx < state.subdivisionColumns; subColIdx++) {\r\n\r\n      // Get source and result positions for the subdivision\r\n      const sourcePositions = state.sourcePositions[subRowIdx][subColIdx];\r\n      const resultPositions = state.resultPositions[subRowIdx][subColIdx];\r\n\r\n      for (let vertexIdx = 0; vertexIdx < vertexCount; vertexIdx++) {\r\n        // First handle if a reset has been requested - if that's the case, just zero out both the source and result and continue\r\n        if (state.resetRequested) {\r\n          fns.setZ(sourcePositions, vertexIdx, state.baseVertexDepth);\r\n          fns.setZ(resultPositions, vertexIdx, state.baseVertexDepth);\r\n          continue;\r\n        }\r\n\r\n        // Map this vertex index to the specific row/column index in the subdivision\r\n        const relativeColumnIdx = vertexIdx % state.rowsPerSubdivision;\r\n        const relativeRowIdx = Math.floor(vertexIdx / state.columnsPerSubdivision);\r\n    \r\n        // Start averaging z-positions across the other \r\n        let adjacentTotal = 0.0;\r\n    \r\n        // Pull from the row above if possible\r\n        if (relativeRowIdx > 0) {     \r\n          const aboveIdx = vertexIdx - state.columnsPerSubdivision;\r\n          adjacentTotal += getZ(sourcePositions, aboveIdx);\r\n        }\r\n        else if (subRowIdx > 0) {\r\n          // Look at the bottom row of the subdivision above\r\n          const aboveSubdivision = state.sourcePositions[subRowIdx - 1][subColIdx];\r\n          const externalAboveIdx = vertexIdx + (state.columnsPerSubdivision * (state.rowsPerSubdivision - 1));\r\n    \r\n          adjacentTotal += getZ(aboveSubdivision, externalAboveIdx);\r\n        }\r\n    \r\n        // Pull from the row below if possible\r\n        if (relativeRowIdx < state.rowsPerSubdivision - 1) {\r\n          const belowIdx = vertexIdx + state.columnsPerSubdivision;\r\n          adjacentTotal += getZ(sourcePositions, belowIdx);\r\n        }\r\n        else if (subRowIdx < state.subdivisionRows - 1) {\r\n          // Look at the top row of the subdivision below\r\n          const belowSubdivision = state.sourcePositions[subRowIdx + 1][subColIdx];\r\n          const externalBelowIdx = vertexIdx % state.columnsPerSubdivision;\r\n    \r\n          adjacentTotal += getZ(belowSubdivision, externalBelowIdx);\r\n        }\r\n    \r\n        // Pull from the column on the left if possible\r\n        if (relativeColumnIdx > 0) {\r\n          adjacentTotal += getZ(sourcePositions, vertexIdx - 1);\r\n        }\r\n        else if (subColIdx > 0) {\r\n          // Look at the rightmost column of the subdivision to the left\r\n          const leftSubdivision = state.sourcePositions[subRowIdx][subColIdx - 1];\r\n          const externalLeftIdx = vertexIdx + (state.columnsPerSubdivision - 1);\r\n    \r\n          adjacentTotal += getZ(leftSubdivision, externalLeftIdx);\r\n        }\r\n    \r\n        // Pull from the column on the right if possible\r\n        if (relativeColumnIdx < state.columnsPerSubdivision - 1) {\r\n          adjacentTotal += getZ(sourcePositions, vertexIdx + 1);\r\n        }\r\n        else if (subColIdx < state.subdivisionColumns - 1) {\r\n          // Look at the leftmost column of the subdivision to the right\r\n          const rightSubdivision = state.sourcePositions[subRowIdx][subColIdx + 1];\r\n          const externalRightIdx = vertexIdx - (state.columnsPerSubdivision - 1);\r\n\r\n          adjacentTotal += getZ(rightSubdivision, externalRightIdx);\r\n        }\r\n    \r\n        // Take twice the average of the adjacent points and subtract it from the current position at this index\r\n        let newZValue = Math.min(state.maxVertexDepth, Math.max(state.minVertexDepth, (adjacentTotal / 2.0) - getZ(resultPositions, vertexIdx)));\r\n    \r\n        // Apply damping and store\r\n        newZValue *= state.waveDampingFactor;\r\n        fns.setZ(resultPositions, vertexIdx, newZValue);\r\n      }\r\n    }\r\n  }\r\n\r\n  // Now start building the message, setting transferrable buffers, and doing cleanup\r\n  const transferObjects = [];\r\n  const message = {\r\n    type: 'result',\r\n    vertexPositions: [],\r\n    vertexColors: []\r\n  };\r\n\r\n  for(let subRowIdx = 0; subRowIdx < state.subdivisionRows; subRowIdx++) {\r\n\r\n    // Ensure that we have arrays for this row index\r\n    message.vertexPositions[subRowIdx] = [];\r\n    message.vertexColors[subRowIdx] = [];\r\n\r\n    for(let subColIdx = 0; subColIdx < state.subdivisionColumns; subColIdx++) {\r\n\r\n      // Get the result positions for this subdivision\r\n      const resultPositions = state.resultPositions[subRowIdx][subColIdx];\r\n\r\n      // Copy that into a transferrable array\r\n      const positionArray = new Float32Array(resultPositions);\r\n      message.vertexPositions[subRowIdx][subColIdx] = positionArray;\r\n      transferObjects.push(positionArray.buffer);\r\n\r\n      // Generate colors\r\n      const colorArray = new Float32Array(vertexCount * 3)\r\n      for(let vertexIndex = 0, arrayOffset = 0; vertexIndex < vertexCount; vertexIndex++, arrayOffset += 3)\r\n      {\r\n        const scaledColor = fns.getScaledColor(positionArray, vertexIndex);\r\n        colorArray[arrayOffset] = scaledColor;\r\n        colorArray[arrayOffset + 1] = scaledColor;\r\n        colorArray[arrayOffset + 2] = 1.0; // Blue channel is fixed\r\n      }\r\n\r\n      message.vertexColors[subRowIdx][subColIdx] = colorArray;\r\n      transferObjects.push(colorArray.buffer);\r\n\r\n      // Swap source and result positions for next time\r\n      const swap = resultPositions;\r\n      state.resultPositions[subRowIdx][subColIdx] = state.sourcePositions[subRowIdx][subColIdx];\r\n      state.sourcePositions[subRowIdx][subColIdx] = swap;\r\n    }\r\n  }\r\n\r\n  // We've processed any requested reset by now\r\n  state.resetRequested = false;\r\n\r\n  // Post the message\r\n  postMessage(message, transferObjects);\r\n};\r\n\r\nonmessage = function(e) {\r\n  switch(e.data.type) {\r\n    case 'init':\r\n      fns.handleInit(e.data);\r\n      break;\r\n\r\n    case 'reset':\r\n      fns.handleReset();\r\n      break;\r\n\r\n    case 'pointer':\r\n      fns.handlePointer(e.data);\r\n      break;\r\n\r\n    case 'ready':\r\n      fns.handleReady();\r\n      break;\r\n\r\n    default:\r\n      console.warn(`unrecognized message type: ${e.data.type}`, e);\r\n  }\r\n};\r\n","import unsupportedIterableToArray from \"./unsupportedIterableToArray.js\";\nexport default function _createForOfIteratorHelper(o, allowArrayLike) {\n  var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n\n  if (!it) {\n    if (Array.isArray(o) || (it = unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n\n      var F = function F() {};\n\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function s() {\n      it = it.call(o);\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}"],"names":["_arrayLikeToArray","arr","len","length","i","arr2","Array","_unsupportedIterableToArray","o","minLen","n","Object","prototype","toString","call","slice","constructor","name","from","test","_slicedToArray","isArray","_i","Symbol","iterator","_s","_e","_arr","_n","_d","next","done","push","value","err","TypeError","state","subdivisionRows","subdivisionColumns","columnsPerSubdivision","rowsPerSubdivision","minVertexDepth","maxVertexDepth","baseVertexDepth","vertexDepthRange","waveDampingFactor","sourcePositions","resultPositions","resetRequested","pendingPointerEvents","Map","fns","positions","vertexIndex","getZ","data","subRowIdx","subColIdx","Float32Array","vertexPositionTemplate","clear","key","rowIndex","columnIndex","set","handleReady","vertexCount","allowArrayLike","it","F","s","e","f","normalCompletion","didErr","step","_e2","pointerEvent","setZ","vertexIdx","relativeColumnIdx","relativeRowIdx","Math","floor","adjacentTotal","newZValue","min","max","transferObjects","message","type","vertexPositions","vertexColors","positionArray","buffer","colorArray","arrayOffset","scaledColor","getScaledColor","swap","postMessage","onmessage","handleInit","handleReset","handlePointer","console","warn"],"sourceRoot":""}